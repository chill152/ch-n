<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Reveal Image with Hand Gesture</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 100; color: white; background: rgba(0,0,0,0.7); padding: 20px; border-radius: 12px; border: 1px solid #444; }
        #video_container { position: absolute; bottom: 15px; right: 15px; width: 150px; height: 110px; border-radius: 8px; overflow: hidden; border: 1px solid #666; transform: scaleX(-1); }
        video { width: 100%; height: 100%; object-fit: cover; }
        input[type="color"] { border: none; width: 100%; height: 30px; cursor: pointer; background: none; margin-top: 10px; }
        .hint { font-size: 11px; color: #00ffcc; margin-top: 10px; }
    </style>
</head>
<body>

<div id="ui">
    <h3 style="margin:0">Hạt Mở Ảnh 3D</h3>
    <input type="color" id="colorPicker" value="#00fbff">
    <div id="status" style="margin-top:10px; font-size:12px">Đang tải AI...</div>
    <div class="hint">• Chụm tay: Che ảnh<br>• Xòe ngón cái & trỏ: Mở ảnh</div>
</div>

<div id="video_container">
    <video id="input_video"></video>
</div>

<script>
    // --- CẤU HÌNH THREE.JS ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.z = 500;

    // --- TẠO ẢNH PHÍA SAU ---
    const loader = new THREE.TextureLoader();
    // Bạn có thể thay đổi link ảnh ở đây
    const imgUrl = 'https://www.pinterest.com/pin/300404237650697700/'; 
    let photoMesh;

    loader.load(imgUrl, (texture) => {
        const geometry = new THREE.PlaneGeometry(400, 300);
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
        photoMesh = new THREE.Mesh(geometry, material);
        photoMesh.position.z = -50; // Nằm sau lớp hạt
        scene.add(photoMesh);
    });

    // --- TẠO HỆ THỐNG HẠT (CHẮN ẢNH) ---
    const particleCount = 5000;
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(particleCount * 3);
    const dest = new Float32Array(particleCount * 3); // Vị trí khi mở ra

    for (let i = 0; i < particleCount; i++) {
        // Trạng thái đóng: Hình cầu đặc che ảnh
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const r = 180; 

        pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        pos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        pos[i * 3 + 2] = r * Math.cos(phi) + 50; // Đẩy lên trước ảnh

        // Trạng thái mở: Các hạt dạt ra biên
        dest[i * 3] = pos[i * 3] * 3; 
        dest[i * 3 + 1] = pos[i * 3 + 1] * 3;
        dest[i * 3 + 2] = pos[i * 3 + 2];
    }

    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pos), 3));
    const mat = new THREE.PointsMaterial({ size: 2.5, color: 0x00fbff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
    const points = new THREE.Points(geo, mat);
    scene.add(points);

    // --- AI NHẬN DIỆN TAY ---
    const videoElement = document.getElementById('input_video');
    const statusText = document.getElementById('status');
    let revealFactor = 0; // 0: Đóng, 1: Mở hoàn toàn
    let targetRotY = 0;

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            statusText.innerText = "Tay đang điều khiển";
            const hand = results.multiHandLandmarks[0];
            
            // Xoay trục theo tay
            targetRotY = (hand[0].x - 0.5) * 2;

            // Tính độ xòe ngón cái (4) và ngón trỏ (8)
            const d = Math.sqrt(
                Math.pow(hand[4].x - hand[8].x, 2) + 
                Math.pow(hand[4].y - hand[8].y, 2)
            );
            
            // Cập nhật mức độ mở ảnh (từ 0.05 đến 0.2)
            revealFactor = Math.min(Math.max((d - 0.05) * 7, 0), 1);
        } else {
            statusText.innerText = "Hãy giơ tay trước cam";
            revealFactor = 0;
        }
    }

    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraUtils.start();

    // --- VÒNG LẶP CẬP NHẬT ---
    function animate() {
        requestAnimationFrame(animate);

        // Tự động xoay nhẹ nhàng quanh trục
        points.rotation.y += 0.005 + (targetRotY * 0.05);
        if(photoMesh) photoMesh.rotation.y = points.rotation.y * 0.5;

        // Di chuyển từng hạt dựa trên revealFactor
        const currentPos = geo.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            // Nội suy (Interpolation) giữa vị trí đóng và vị trí mở
            currentPos[i3] += ( (pos[i3] + (dest[i3] - pos[i3]) * revealFactor) - currentPos[i3] ) * 0.1;
            currentPos[i3+1] += ( (pos[i3+1] + (dest[i3+1] - pos[i3+1]) * revealFactor) - currentPos[i3+1] ) * 0.1;
            currentPos[i3+2] += ( (pos[i3+2] + (dest[i3+2] - pos[i3+2]) * revealFactor) - currentPos[i3+2] ) * 0.1;
        }
        geo.attributes.position.needsUpdate = true;

        // Hiệu ứng hạt mờ dần khi mở ảnh để nhìn rõ ảnh hơn
        mat.opacity = 0.8 - (revealFactor * 0.5);

        renderer.render(scene, camera);
    }

    document.getElementById('colorPicker').addEventListener('input', (e) => {
        mat.color.set(e.target.value);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
