<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>3D Birthday Cake Particles</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0010; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 100; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 12px; border: 1px solid #ff00ff; }
        #video_container { position: absolute; bottom: 15px; right: 15px; width: 150px; height: 110px; border-radius: 8px; overflow: hidden; transform: scaleX(-1); border: 1px solid #ff00ff; }
        video { width: 100%; height: 100%; object-fit: cover; }
        .hint { font-size: 11px; color: #ff99ff; margin-top: 8px; }
        input[type="color"] { width: 100%; height: 30px; cursor: pointer; border: none; background: none; }
    </style>
</head>
<body>

<div id="ui">
    <h3 style="margin:0; color: #ff66cc;">Bánh Sinh Nhật Hạt 3D</h3>
    <input type="color" id="colorPicker" value="#ff66cc">
    <div id="status" style="margin-top:10px; font-size:12px">Đang tải...</div>
    <div class="hint">• Chụm tay: Hiện bánh sinh nhật<br>• Xòe tay: Mở quà (Hiện ảnh)</div>
</div>

<div id="video_container">
    <video id="input_video"></video>
</div>

<script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.z = 500;

    // --- TẢI ẢNH (QUÀ TẶNG) ---
    const loader = new THREE.TextureLoader();
    // THAY LINK ẢNH CỦA BẠN TẠI ĐÂY
    const imgUrl = 'sinhnhat.jpg'; 
    let photoMesh;
    loader.load(imgUrl, (texture) => {
        const geometry = new THREE.PlaneGeometry(300, 300);
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0 });
        photoMesh = new THREE.Mesh(geometry, material);
        photoMesh.position.z = -20;
        scene.add(photoMesh);
    });

    // --- TẠO HÌNH BÁNH SINH NHẬT TỪ HẠT ---
    const particleCount = 6000;
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(particleCount * 3);
    const dest = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++) {
        let x, y, z;
        
        // Chia hạt thành 3 phần: Thân bánh, mặt bánh và nến
        if (i < 4000) { 
            // Thân bánh (Hình trụ)
            const angle = Math.random() * Math.PI * 2;
            const radius = 120;
            const height = Math.random() * 100 - 50;
            x = Math.cos(angle) * radius;
            z = Math.sin(angle) * radius;
            y = height;
        } else if (i < 5500) { 
            // Mặt bánh (Hình tròn phẳng)
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 120;
            x = Math.cos(angle) * radius;
            z = Math.sin(angle) * radius;
            y = 50;
        } else { 
            // Cây nến (Trụ nhỏ ở giữa)
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 5;
            x = Math.cos(angle) * radius;
            z = Math.sin(angle) * radius;
            y = 50 + Math.random() * 60;
        }

        pos[i * 3] = x;
        pos[i * 3 + 1] = y;
        pos[i * 3 + 2] = z;

        // Vị trí bung tỏa khi mở tay (nổ tung như pháo hoa)
        dest[i * 3] = x * 4;
        dest[i * 3 + 1] = y * 4;
        dest[i * 3 + 2] = z * 4;
    }

    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pos), 3));
    const mat = new THREE.PointsMaterial({ size: 2, color: 0xff66cc, transparent: true, blending: THREE.AdditiveBlending });
    const points = new THREE.Points(geo, mat);
    scene.add(points);

    // --- AI HANDS ---
    const videoElement = document.getElementById('input_video');
    let revealFactor = 0;
    let targetRotY = 0;

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const hand = results.multiHandLandmarks[0];
            targetRotY = (hand[0].x - 0.5) * 4;
            const d = Math.sqrt(Math.pow(hand[4].x - hand[8].x, 2) + Math.pow(hand[4].y - hand[8].y, 2));
            revealFactor = Math.min(Math.max((d - 0.05) * 8, 0), 1);
        } else {
            revealFactor = 0;
        }
    }

    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
    hands.onResults(onResults);

    new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    }).start();

    // --- ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);

        points.rotation.y += 0.01 + (targetRotY * 0.02);
        if(photoMesh) photoMesh.rotation.y = points.rotation.y;

        const currentPos = geo.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const targetX = pos[i3] + (dest[i3] - pos[i3]) * revealFactor;
            const targetY = pos[i3+1] + (dest[i3+1] - pos[i3+1]) * revealFactor;
            const targetZ = pos[i3+2] + (dest[i3+2] - pos[i3+2]) * revealFactor;

            currentPos[i3] += (targetX - currentPos[i3]) * 0.1;
            currentPos[i3+1] += (targetY - currentPos[i3+1]) * 0.1;
            currentPos[i3+2] += (targetZ - currentPos[i3+2]) * 0.1;
        }
        geo.attributes.position.needsUpdate = true;

        if (photoMesh) {
            photoMesh.material.opacity = revealFactor;
            photoMesh.scale.set(revealFactor, revealFactor, revealFactor);
        }

        renderer.render(scene, camera);
    }

    document.getElementById('colorPicker').addEventListener('input', (e) => {
        mat.color.set(e.target.value);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
